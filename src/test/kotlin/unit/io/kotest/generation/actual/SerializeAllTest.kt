package io.kotest.generation.actual

import io.kotest.core.spec.style.WordSpec
import io.kotest.core.test.TestCase
import io.kotest.core.test.TestResult
import io.kotest.generation.Box
import io.kotest.matchers.shouldBe
import java.io.File
import java.math.BigDecimal
import java.time.LocalDate

class SerializeAllTest: WordSpec() {
    private val today = LocalDate.of(2024, 2, 23)
    private val box = Box(BigDecimal.ONE, BigDecimal.TEN, BigDecimal.ONE)

    override suspend fun afterTest(testCase: TestCase, result: TestResult) {
        super.afterTest(testCase, result)
        sequenceOf("ActualBox.kt", "AssertionsFromBox.kt", "MockkFromBox.kt", "ParameterizedMockksFromBox.kt")
            .forEach { deleteIfExists(it) }
    }

    init {
        "serializeForTests" should {
            "write instance as object" {
                testAndDispose("ActualBox.kt") { fileName ->
                    serializeForTests(box, today)
                    File(fileName).readText() shouldBe """package generated.code

import io.kotest.generation.Box
import java.math.BigDecimal
import java.time.LocalDate

// generated by com.tgt.trans.dmo.common:kotests-generator
object ActualBox {
val box0 = Box(
length = BigDecimal("1"),
width = BigDecimal("10"),
height = BigDecimal("1")
)

val localDate1 = LocalDate.of(2024, 2, 23)
}""".trimIndent()
                }
            }
            "write instance as assertions" {
                testAndDispose("AssertionsFromBox.kt") { fileName ->
                    serializeForTests(box, today)
                    File(fileName).readText() shouldBe """package generated.code

import io.kotest.assertions.assertSoftly
import io.kotest.matchers.shouldBe
import io.kotest.generation.Box
import java.math.BigDecimal

// generated by com.tgt.trans.dmo.common:kotests-generator
object SerializedAssertions {
fun assertion0(actual: Box)
{
assertSoftly {
 actual.length shouldBe BigDecimal("1")
actual.width shouldBe BigDecimal("10")
actual.height shouldBe BigDecimal("1")
}
}

fun assertion1(actual: Any)
{
assertSoftly {
 //Cannot serialize java.time.LocalDate because not a data class
}
}
}""".trimIndent()
                }
            }
            "write instance as mockk" {
                testAndDispose("MockkFromBox.kt") { fileName ->
                    serializeForTests(box, today)
                    File(fileName).readText() shouldBe """
package generated.code

import io.mockk.every
import io.mockk.mockk
import io.kotest.generation.Box
import java.math.BigDecimal

// generated by com.tgt.trans.dmo.common:kotests-generator
object SerializedMocks {
fun mock0(): Box {
val ret = mockk<Box>()
every { ret.length } returns BigDecimal("1")
every { ret.width } returns BigDecimal("10")
every { ret.height } returns BigDecimal("1")
return ret
}

fun mock1(): Any {
val ret = mockk<Any>()
//Cannot serialize java.time.LocalDate because not a data class
return ret
}
}""".trimIndent()
                }
            }
            "write instance as parameterized mockk" {
                testAndDispose("ParameterizedMockksFromBox.kt") { fileName ->
                    serializeForTests(box, today)
                    File(fileName).readText() shouldBe """
package generated.code

import io.mockk.every
import io.mockk.mockk
import io.kotest.generation.Box
import java.math.BigDecimal

// generated by com.tgt.trans.dmo.common:kotests-generator
object SerializedMocks {
fun mock0(
length: BigDecimal = BigDecimal("1"),
width: BigDecimal = BigDecimal("10"),
height: BigDecimal = BigDecimal("1")
): Box {
val ret = mockk<Box>()
every { ret.length } returns length
every { ret.width } returns width
every { ret.height } returns height
return ret
}

fun mock1(
//Cannot serialize java.time.LocalDate because not a data class
): Any {
val ret = mockk<Any>()
//Cannot serialize java.time.LocalDate because not a data class
return ret
}
}""".trimIndent()
                }
            }
        }
    }

    private fun testAndDispose(fileName: String, block: (String) -> Unit) {
        deleteIfExists(fileName)
        try {
            block(fileName)
        } finally {
            deleteIfExists(fileName)
        }
    }

    private fun deleteIfExists(fileName: String) = try {
        File(fileName).delete()
    } catch (ex: Exception) {
        println(ex.message)
    }
}